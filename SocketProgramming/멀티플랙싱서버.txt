I/O 멀티 플랙싱

멀티 프로세스 기반 다중접속 서버의 문제점

- 프로세스의 빈번한 생성은 성능 저하 발생
- 멀티 프로세스의 흐름을 고려해 구현하므로 구현이 어려움
- 프로세스 간 통신이 필요한 상황에서 서버 구현이 복잡

대안

- 하나의 프로세스가 다수 클라이언트 요청 처리할 수 있게 함
- 하나의 프로세스가 다수 클라이언트 소켓 제어
=> 멀티 플랙싱 서버


멀티 프로세스 서버
- 클라이언트와 서버의 송수신 데이터의 용량이 클 경우
- 송수신이 쉬지 않고 연속적으로 발생하는 경우

멀티 플랙싱 서버
- 클라이언트와 서버의 송수신 데이터 용량이 작은 경우
- 송수신이 연속적이지 않은 경우
- 멀티 프로세스 기반에 비해 많은 수의 클라이언트 처리



I/O 멀티 플랙싱

1. 이를 활용하면 하나의 프로세스에서 여러 개의 파일 제어 가능
2. 배열 기반의 I/O 멀티 플랙싱은 프로세스가 여러 개 파일을 다루기 위해서 파일 디스크립터를 비트배열로 관리
- 데이터 변경을 감시할 파일 디스크립터를 배열에 포함
- 관리 파일들 중 파일 상태 변화가 발생하면 대응되는 배열에 표시
- 프로세스는 배열 값을 검사하여 처리 결정
3. 배열 기반 I/O 멀티 플랙싱은 단순하여 널리 사용
- 최대 관리 가능한 파일 수가 제한됨
- 항상 배열의 모든 원소 확인을 통하므로 성능 저하 발생
- 순차 처리를 하기 때문에 파일 변경 시 처리량이 많을 경우 부적합
4. 이벤트 기반의 I/O 멀티 플랙싱 : epoll 이용(LINUX, 비표준)




Select 함수


int select(int maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timval* timeout);
성공 : 변화 발생한 디스크립터 수, 타임아웃 : 0, 실패 : -1

- maxfd : 검사 대상이 되는 파일(소켓) 디스크립터의 수
- readset : 읽기(수신) 여부를 관찰할 파일(소켓) 디스크립터의 집합
- writeset : 쓰기(송신) 여부를 관찰할 파일(소켓) 디스크립터의 집합
- exceptset : 예외 여부를 관찰할 파일(소켓) 디스크립터의 집합
- timeout : timeout, 함수 호출 후 무한 대기 상태에 빠지지 않기 위한 타임아웃 값 NULL로 설정 시, 무한 대기


1. select 함수 이용 시,다음 사항 확인 가능
- 어떤 소켓으로 메세지가 수신되었는가
- 어떤 소켓을 통해 메세지 송신이 가능한가
- 어떤 소켓에서 예외 사항이 발생했는가?

2. I/O 멀티 플랙싱은 여러 파일에서 발생하는 입출력을 동시에 관리할 수 있음

3. 입출력에 관리할 파일 들을 'fd_set' 비트 배열에 넣고 비트 배열 값의 변경 여부를 관찰

* 매크로

FD_ZERO(fd_set* fdset);
- 인자로 전달된 주소의 fd_set형 변수의 모든 비트를 0으로 초기화

FD_SET(int fd, fd_set* fdset);
- fd로 전달된 값을 인덱스로 비트배열 fd_set에 설정

FD_CLR(int fd, fd_set* fdset);
- fd로 전달된 값을 인덱스로 비트배열 fd_set에 설정 해제

FD_ISSET(int fd, fd_set* fdset)
- fd로 전달된 값을 인덱스로 비트배열 fd_set을 통해 변화 발생 여부 확인

4. 성공적으로 반환된 경우
- 변경이 발생한 파일(소켓) 디스크립터와 대응되는 비트 인덱스 값이 1로 바뀌며, 나머지는 0으로 처리


